## 析构函数调用顺序

程序的执行过程中，对象如果用`new`运算符开辟了空间，则在类中 `应该` 定义一个析构函数，并在析构函数中使用`delete`删除由`new`分配的内存空间。因为在撤销对象时，**系统自动收回为对象所分配的存储空间，而不能自动收回由new分配的动态存储空间**。


```c++
class Str {
    char *Sp;
    int Length;

public:
    Str(char *string) {
        if (string) {
            Length = strlen(string);
            // 在构造函数中将成员数据指针 指向动态开辟的内存
            Sp = new char[Length + 1];
            // 用初值为开辟的内存赋值
            stpcpy(Sp, string);
        } else {
            Sp = 0;
        }
    }
    
    void Show(void) {
        cout << Sp << endl;
    }
    
    // 析构函数，当释放对象时收回用new开辟的空间
    ~Str() {
        if (Sp) {
            delete []Sp;
        }
    }
};

```

+ 用`new`运算符为对象分配动态存储空间时候，调用了个构造函数，用`delete`删除这个空间时，调用了析构函数。当使用运算符`delete`删除一个由`new`动态产生的对象时，它首先调用该对象的析构函数，然后再释放这个对象占用的内存空间。


不同存储类型的对象调用**构造函数**和**析构函数**
+ **对于全局定义的对象**（函数外定义的对象）。在程序开始执行时，调用构造函数；到程序结束时，调用析构函数。
+ **对于局部定义的对象**（在函数内定义的对象），当程序执行到定义对象的地方时，调用构造函数；在**退出对象的作用域**时，调用析构函数。
+ **用static定义的局部对象**，在首次到达对象的定义时调用构造函数；到程序结束时，调用析构函数。
+ **对于用new运算符动态生成的对象**，在产生对象时调用构造函数，只有**delete**运算来释放对象，才能调用析构函数。如果不使用delete来撤销动态生成的对象，程序结束时，对象仍存在，并占用相应的存储空间，电脑也会越来越卡，**既系统不能自动地调用析构函数来撤销动态生成的对象**；


**动态构造及析构对象数组**
用**new**运算符来动态生成对象数组时，自动调用构造函数，而用**delete**运算符来释放**p1**所指向的对象数组时占用的存储空间时，在指针变量的前面必须加上`[]`；才能将数组元素所占用的空间全部释放。否则。只是放第0个元素所占用的空间

```c++
p1 = new Test[3];
...
delete []p1;
```

## 缺省的析构函数
如果在类的定义中没有 显示的定义析构函数时候，则编译器会自动地产生一个缺省的析构函数，其格式为:
> ClassName::~ClassName() {};
 
任何对象都必须有 **构造函数** 和 **析构函数**。但是在撤销对象时，要释放对象的数据成员用 new 运算符分配的动态空间时，必须显示地定义析构函数。
## 虚函数

多态性：调用**同一个函数名**，可以根据需要**实现不同的功能**。
**多态性**：分为两种：
+ 编译时的多态性（函数重载）
+ **运行时的多态性**（虚函数）

**运行时的多态性**是指**在程序执行之前**，根据函数名和参数无法确定应该调用哪一个函数，必须在程序的执行过程中，根据具体的执行情况来动态地确定。

如果要访问派生类中相同名字的函数，必须将基类中的**同名函数定义为虚函数**，这样将`不同的派生类对象的地址赋值给基类的指针变量`后，就可以**动态的根据这种赋值语句调用不同类中的函数**。


## 虚函数的定义和使用
可在程序`运行时`通过`调用相同的函数名`而`实现不同功能的函数`称为**虚函数**。
> virtual <类型> FuncName (参数列表);

一旦把基类的成员函数定义为虚函数，由基类所派生出来的所有派生类中，该函数均保持虚函数的特性。
**在派生类中重新定义基类的虚函数时，可以不用关键字virtual来修饰这个成员函数**。

虚函数是用关键字 `virtual` 修饰的某基类中的`protected`或`public`成员函数，它可以在派生类中重新定义，以形成不同版本。
**只有在程序的执行过程中，依据指针具体指向哪个类对象，或依据引用哪个类对象，才能确定激活哪一个版本，实现动态聚束。**

## 虚函数，说明一下几点:

+ 当在基类中把 **成员函数定义为虚函数后，在其派生类中定义的虚函数必须与基类中的虚函数同名，参数的类型、顺序、参数的个数必须一一对应，函数返回的类型也相同。**
如果函数名相同，但是参数个数不同或者参数的类型不同时。`则属于函数的重载，而不是虚函数`。如果函数名不同，显然这是不同的成员函数。

+ 实现这种动态的多态性时，必须使用**基类类型的指针变量**，并使该指针**指向不同的派生类对象**，`并通过调用指针所指向的虚函数才能实现动态的多态性`。

+ **虚函数必须是类的一个成员函数，不能是友元函数，也不能是静态的成员函数**；

+ 在派生类中**没有重新定义虚函数时**，与一般成员函数一样，当调用这种**派生类对象的虚函数**时，**则调用其基类中的虚函数**。

+ 可把**析构函数定义为虚函数**，但是不能将**构造函数定义为虚函数**。

+ 虚函数与一般的成员函数相比较，**调用时的执行速度要慢一些**。为了实现多态性，在每一个派生类中均要保存相应虚函数的入口地址表，函数的调用机制也是间接实现的。因此，除了要编写一些通用的程序，并一定要使用虚函数才能完成其功能要求外，通常不必使用虚函数。

8、一个函数如果被定义成虚函数，则不管经历多少次派生，仍将保持其虚特性，以实现**“一个接口，多个形态”**。


## 虚函数的访问
用**基指针访问**与**用对象名访问**
**用基指针访问虚函数时，指向器实际派生类对象重新定义的函数。实现动态聚束。**
通过一个**对象名**访问时，只能静态聚束。即由编译器在编译的时候决定调用哪个函数。


## 纯虚函数

基类中的不对虚函数给出有意义的实现。只是在派生类中有具体的意义。
这是基类中虚函数只是一个**入口**，具体的目的地由不同的派生类中的对象决定，这个虚函数称为**纯虚函数**。

```c++
class <基类名> {
    virtual <类型><函数名>(<参数列表>) = 0;
    ...
    ...
}
```

+ 在定义纯虚函数时，不能定义纯虚函数的实现部分(基类中不能写实现)。
2、**把函数名赋与0，本质上是将指向函数体的指针值赋为初值0**。与定义空函数不一样，空函数的函数体为空，即调用该函数时，不执行任何动作。**在没有重新定义这种纯虚函数之前，是不能调用这种函数的**。
3、**把至少包含一个纯虚函数的类，成为抽象类**。这种类只能作为派生类的基类，**不能用来创建这种类的对象**。
理由很明显：因为`虚函数没有实现部分`，`所以不能产生对象`。但可以定义指向抽象类的指针，即指向这种基类的指针。当用这种基类指针指向其派生类的对象时，**必须在派生类中重载纯虚函数，否则会产生程序的运行错误**。
4、在以抽象类作为基类的派生类中必须有纯虚函数的实现部分，**即必须有重载纯虚函数的函数体**，否则，这样的派生类也是不能产生对象的。


总结：**抽象类的唯一用途是为派生类提供基类**，`纯虚函数的作用是作为派生类中的成员函数的基础，并实现多态性。`

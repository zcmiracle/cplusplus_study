## cin、函数重载、extern "C"、cout、默认参数

## cin、cout

+ C++中常使用`cin`、`cout`进行控制台的输入、输出
    + `cin`用的右移运算符 >>
    + `cout`用的左移运算符 <<
    + `endl`换行 
+ `getchar()`等待键盘输入，如果敲回车，就会读取键盘输入


## 函数重载 
+ 规则：
    + 函数名相同
    + 参数个数、参数顺序、参数类型不同
+ **注意**：
    + 返回值类型与函数重载无关，会造成歧义，直接报错
    + **调用函数时，实参的隐式类型转换可能会产生二义性**
+ 本质:
    + 采用了`name mangling`或者叫`name decoration`技术
    + C语言并不会根据参数进行改编、修饰，所以C语言不支持函数重载
    + C++编译器默认会对 `符号名`（函数名）进行**改编、修饰**
    + 重载时会生成多个不同的函数名，不同编译器（MSVC、g++）有不同的生成规则
    
    
## 默认参数
+ C++允许函数设置默认参数，在调用时可以根据情况省略实参。
    + 默认参数只能按照**右到左**的顺序
    + **如果函数同时有声明、实现，默认参数只能放在函数声明中**
    + 默认参数的值可以是常量、全局符号(全局变量、函数名)
    + C语言也可以将函数名作为参数传递，只是没有默认参数

+ 函数重载、默认参数可能会产生冲突、二义性（建议优先使用默认参数）


## extern "C"
+ 被`extern "C"`修饰的代码会按照`C语言`的方式去`编译`
+ 如果函数同时有声明和实现，**要让函数声明被extern "C"修饰**，函数实现可以不修饰
+ 由于`C`、`C++`编译规则的不同，在C、C++混合开发时，可能会出现以下操作：
    + 在C++调用C语言API时候，需要使用`extern "C"修饰C语言函数声明`
+ 编写C语言代码中直接使用`extern "C"`，这样可以直接被C++调用，但是如果C语言调用就会报错，所有用以下方式：
    + 通过宏 `__cplusplus`来区分C、C++环境
    
    ```c++
    #ifdef __cplusplus
    extern "C" {
    #ifdef __cplusplus
    
    int sum(int a, int b);
    
    #ifdef __cplusplus
    }
    #ifdef __cplusplus
    ``` 

## #pragma once
+ 使用 `#ifndef`、`#define`、`#endif`来**防止头文件的内容被重复包含**
+ `#pragma once`可以防止整个文件的内容被重复包含

+ **区别：**
    + `#ifndef`、`#define`、`#endif`受C/C++标准库的支持，不受编译器的任何限制
    + 有些编译器不支持`#pragma once`，兼容性不够好
    + `#ifndef`、`#define`、`#endif`可以只针对一个文件中的部分代码，而`#pragma once`只能针对整个文件      
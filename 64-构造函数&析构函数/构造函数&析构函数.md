##  构造函数 && 析构函数

## 构造函数

`构造函数` 和 `析构函数` 是在类体中说明的两种 **特殊的成员函数**。
**构造函数**是在创建对象时，使用给定的值来讲对象初始化。
**析构函数**的功能正好相反，是在系统释放对象前，对 对象做一些善后工作。

构造函数 **可以带参数、可以重载**，同时没有返回值。
构造函数是类的成员函数，系统约定构造函数名必须与类名相同。
**构造函数提供了初始化对象的一种简单的方法。**

**构造函数注意点**：
+ **构造函数的函数名与类名相同**。构造函数的主要作用是`完成初始化对象的数据成员以及其他的初始化工作`。
+ 定义构造函数时，**不能指定函数返回值的类型，也不能指定为void类型**。
+ **一个类可以定义若干个构造函数**。当定义多个构造函数时，必须满足**函数重载**的原则。
+ **构造函数可以指定参数的缺省值。**
+ 若定义的类要说明该类的对象时，构造函数必须是**公有的成员函数**。如果定义类仅用于派生其他类时，则可将构造函数定义为**保护的成员函数**。

## 缺省构造函数
定义类时，若没有定义类的构造函数，则编译器**自动**产生一个缺省的构造函数，格式为：
> className::className() { }

缺省构造函数**并不对所产生对象的数据成员赋初值**，即**新产生对象的数据成员的值是不确定的**。


**局部对象、静态对象、全局对象**的初始化：
**局部对象**：每次定义对象时，都要调用构造函数
**静态对象**：首次定义对象时，调用构造函数的，且由于对象一直存在，**只调用一次构造函数**。
**全局对象**：**在`main`函数执行之前调用构造函数的。**

**缺省构造函数注意点**：
+ 定义类时，只要**显式**定义了一个类的构造函数，则编译器就不产生缺省的构造函数
+ 所有的对象在定义时，必须调用构造函数。**不存在没有构造函数的对象**
+ 类中，若定义了没有参数的构造函数，或各参数均有缺省值的构造函数 **也称为缺省的构造函数**，**缺省的构造函数只能有一个**。
+ 产生对象时，系统必定要调用构造函数。**所以任意对象的构造函数必须唯一**





1、**创建对象的时候，一定要调用构造函数**，`显示调用自己写的构造函数 或 编译器生成的缺省的构造函数`
2、创建的时候，如果参数列表与构造函数不一致，对象创建失败。如果有很多构造函数，只要有一个匹配上，就是重载，可以创建成功。
3、局部对象、静态对象、全局对象的初始化。对于局部对象，每次定义对象时，都要调用构造函数。对于静态对象，是在首次定义对象时，调用构造函数的，且由于对象一直存在，**只调用一次构造函数**
4、对于全局对象，是在main函数执行之前调用构造函数的。


## 构造函数与new运算符
+ 可以使用new 运算符来**动态的**建立对象，建立时**要自动调用构造函数**，以便完成初始化对象的数据成员，最后返回这个动态对象的起始地址。
+ 用**new**运算符产生的动态对象，在不在使用这种对象时，必须用**delete**运算符来释放所占用的存储空间。
+ **用new建立类的对象时，可以使用参数初始化动态空间**


## 析构函数
+ 析构函数的作用域构造函数正好相反，是在对象的生命期结束时，释放系统为对象所分配的空间，即要撤销一个对象。
+ 析构函数 **没有类型，没有参数列表，没有返回值**
+ **析构函数也是类的成员函数**，定义析构函数的格式为：

```C++
ClassName::~ClassName() {
    ...
    // 函数体；
}
```
+ 析构函数是**成员函数**，函数体可写在类体内，也可以写在类体外。
+ 析构函数是一个特殊的成员函数，函数名必须与类名相同，并在其前面加上字符 "~" 以便和构造函数名相区别。
+ 析构函数 不能带有 任何参数，不能有返回值，不指定函数类型。
+ 一个类中，只能定义一个析构函数，析构函数不允许重载。
+ 析构函数是在撤销对象时由系统自动调用的。
+ 程序的执行过程中，当遇到某一对象的生存期结束时，系统自定调用析构函数，然后再收回对象分配的存储空间。